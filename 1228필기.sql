20201228

CREATE TABLE T1 
(ID   NUMBER, 
 NAME VARCHAR2(10)) ; 

DESC T1 

---------------------------------------------------------------

SELECT D.DNAME, D.LOC, E.*
FROM DEPT D 
    ,EMP  E 
WHERE D.DEPTNO = E.DEPTNO ; 


CREATE VIEW EMPV 
AS 
SELECT D.DNAME, D.LOC, E.*
FROM DEPT D 
    ,EMP  E 
WHERE D.DEPTNO = E.DEPTNO ; 

SELECT * 
FROM EMPV ;

/*
SELECT * 
FROM (SELECT D.DNAME, D.LOC, E.*
      FROM DEPT D 
          ,EMP  E 
      WHERE D.DEPTNO = E.DEPTNO) ;
--실제로는 뷰를 만들때 썼던 SELECT명령문이 실행된다. */

CREATE VIEW EMPV10
AS 
SELECT * 
FROM EMP 
WHERE DEPTNO = 10 ; 

SELECT * FROM EMPV10 ; 

UPDATE EMPV10 
SET SAL = 6000 
WHERE EMPNO = 7839 ; 

ROLLBACK ;

SELECT * FROM EMP
WHERE EMPNO = 7839 ;

SELECT * FROM EMPV10 ; 

----------------------------------

SELECT * 
FROM DBA_VIEWS
WHERE VIEW_NAME = 'DBA_TABLES'; --안나왔음 질문


--Q. 컬럼 DEPTNO을 가지고 있는 테이블은? 

SELECT *
FROM USER_TAB_COLUMNS
WHERE COLUMN_NAME = 'DEPTNO';

SELECT *
FROM USER_TABLES;

SELET *
FROM USER_TAB_COLUMNS;

SELECT *
FROM USER_SEQUENCES;

SELECT FROM USER_VIEWS;

SELECT *
FROM USER_INDEXES ; 

SELECT *
FROM USER_CONSTRAINTS;


SELECT *
FROM USER_OBJECTS ; 


SELECT * 
FROM USER_TABLES ; 

SELECT * 
FROM ALL_TABLES ; 

SELECT * 
FROM DBA_TABLES ; 

----------------------------------------

SHOW USER;

SELECT MAX(EMPNO) + 1 
FROM EMP ; 

INSERT INTO EMP (EMPNO, .... ) 
VALUES ( MAX(EMPNO) + 1, .... ) ; 

CREATE SEQUENCE EMPNO_SQ 
START WITH 8000 ; 

SELECT EMPNO_SQ.NEXTVAL 
FROM DUAL ; 

INSERT INTO EMP(EMPNO, ENAME, SAL, DEPTNO) 
VALUES (EMPNO_SQ.NEXTVAL, 'ABC', 100,10) ; 

INSERT INTO EMP(EMPNO, ENAME, SAL, DEPTNO) 
VALUES (EMPNO_SQ.NEXTVAL, 'ABC', 100,10) ; 

INSERT INTO EMP(EMPNO, ENAME, SAL, DEPTNO) 
VALUES (EMPNO_SQ.NEXTVAL, 'ABC', 100,10) ; 

INSERT INTO EMP(EMPNO, ENAME, SAL, DEPTNO) 
VALUES (EMPNO_SQ.NEXTVAL, 'ABC', 100,10) ; 

SELECT * 
FROM EMP;

ROLLBACK;


CREATE SEQUENCE EMPNO_SQ ; 

--Q. 시작번호가 1이며, 3씩 증가되는 시퀀스를 생성 (이름: SEQ1) 

CREATE SEQUENCE SEQ1 
START WITH 1 
INCREMENT BY 3;

--Q. 시작번호가 1이며, 1씩 증가되고 최댓값은 30, NOCYCLE 옵션 (이름: SEQ2) 
CREATE SEQUENCE SEQ2
START WITH 1 
INCREMENT BY 1
MAXVALUE 30
NOCYCLE; 



ALTER SEQUENCE SEQ1 
MAXVALUE 100 
MINVALUE 10 
CYCLE ;  --이전에 시작값을 1로했기때문에 문제가 생김


ALTER SEQUENCE SEQ1 
MAXVALUE 100 
MINVALUE -10 
CYCLE ; --이건 가능 


SELECT * 
FROM USER_SEQUENCES ; 

SELECT * 
FROM ALL_SEQUENCES ; 

DROP SEQUENCE SEQ2 ; 

SELECT EMPNO_SQ.NEXTVAL
FROM DUAL ;  --여러번 실행해도 같은값출력(마지막으로 실행한 다음 시퀀스값)

SELECT SEQ1.CURRVAL
FROM DUAL; --아직 숫자를 꺼내본적이없어서 오류

/*
? NEXTVAL은 사용 가능한 다음 시퀀스 값을 반환합니다.
다른 유저인 경우도 포함하여 참조될 때마다 고유 값을
반환합니다.
? CURRVAL은 가장 최근에 발생된 숫자값을 보여줍니다.
? CURRVAL을 통해 확인된 숫자 이후에 숫자가 NEXTVAL을
통해 발생됩니다.
*/


SELECT * FROM USER30.EMPLOYEES ; 

CREATE SYNONYM E1 FOR USER30.EMPLOYEES ; --객체에다 이름을 부여


SELECT *
FROM E1;
----------------------------------------------------------------------


SELECT *
FROM EMP 
WHERE EMPNO = 7788  ;

SELECT ROWID, E.*
FROM EMP E
WHERE EMPNO = 7788  ;


SELECT *
FROM EMP 
WHERE ROWID = 'AAASFqAAAAAABo3AAA' ; 


CREATE INDEX EMP_EMPNO_IX ON EMP(EMPNO) ; 

SELECT EMPNO, ROWID 
FROM EMP 
ORDER BY 1,2 ; 

------------------------------------------------------

CREATE TABLE CUSTOMER 
(CUST_ID NUMBER, 
 CUST_FIRST_NAME VARCHAR2(20), 
 CUST_LAST_NAME VARCHAR2(40), 
 CUST_GENDER CHAR(1), 
 CUST_YEAR_OF_BIRTH NUMBER(4,0), 
 CUST_MARITAL_STATUS VARCHAR2(20), 
 CUST_STREET_ADDRESS VARCHAR2(40), 
 CUST_POSTAL_CODE VARCHAR2(10), 
 CUST_CITY VARCHAR2(30), 
 CUST_STATE_PROVINCE VARCHAR2(40), 
 COUNTRY_ID NUMBER, 
 CUST_MAIN_PHONE_NUMBER VARCHAR2(25), 
 CUST_INCOME_LEVEL VARCHAR2(30), 
 CUST_CREDIT_LIMIT NUMBER, 
 CUST_EMAIL VARCHAR2(30)) ;

/*
Q1. CUST_ID 컬럼에서 사용할 시퀀스 생성 
시작번호 : 100
증가치   : 1 
최댓값   : 9999
캐시    : 100
*/

CREATE SEQUENCE CUST_ID
START WITH 100 
INCREMENT BY 1
MAXVALUE 9999
CACHE 100; 


/*
Q2. CUSTOMER 테이블에 동의어 생성 
CUST 
*/

CREATE SYNONYM CUST
FOR CUSTORMER;



/*
Q3. 인덱스 생성 
CUST_ID 
CUST_FIRST_NAME, CUST_LAST_NAME 
CUST_LAST_NAME 
CUST_YEAR_OF_BIRTH 
*/
CREATE INDEX EMP_EMPNO_IX ON EMP(EMPNO) ;

CREATE INDEX CUST_ID_IDX ON CUSTOMER(CUST_ID);

CREATE INDEX CUST_ID_IDX2 ON CUSTOMER(CUST_FIRST_NAME, CUST_LAST_NAME);

CREATE INDEX CUST_ID_IDX3 ON CUSTOMER(CUST_LAST_NAME );

CREATE INDEX CUST_ID_IDX4 ON CUSTOMER(CUST_YEAR_OF_BIRTH  );


------------------------------------------------------------------------
--SOL
/*
Q1. CUST_ID 컬럼에서 사용할 시퀀스 생성 
시작번호 : 100
증가치   : 1 
최댓값   : 9999
캐시    : 100

CREATE SEQUENCE CUST_SQ 
START WITH 100 
MAXVALUE 9999
CACHE 100 ; 

Q2. CUSTOMER 테이블에 동의어 생성 
CUST 

CREATE SYNONYM CUST FOR CUSTOMER ;

Q3. 인덱스 생성 
CUST_ID 
CUST_FIRST_NAME, CUST_LAST_NAME 
CUST_LAST_NAME 
CUST_YEAR_OF_BIRTH 

CREATE INDEX CUSTOMER_IX01 ON CUSTOMER(CUST_ID) ;
CREATE INDEX CUSTOMER_IX02 
ON CUSTOMER(CUST_FIRST_NAME,CUST_LAST_NAME) ;
CREATE INDEX CUSTOMER_IX03 ON CUSTOMER(CUST_LAST_NAME) ;
CREATE INDEX CUSTOMER_IX04 ON CUSTOMER(CUST_YEAR_OF_BIRTH) ;
*/


-------------------------------------------------------------------
/*
CREATE USER USER01 IDENTIFIED BY ORACLE ; 
CREATE USER USER02 IDENTIFIED BY ORACLE ; 
CREATE USER USER03 IDENTIFIED BY ORACLE ; 

-- GRANT SELECT ON TEST.EMP TO USER01 ;

CREATE OR REPLACE EMPV10
AS 
SELECT EMPNO, ENAME, JOB, MGR, DEPTNO
FROM EMP 
WHERE DEPTNO = 10 ; 

CREATE OR REPLACE EMPV20
AS 
SELECT EMPNO, ENAME, JOB, MGR, DEPTNO
FROM EMP 
WHERE DEPTNO = 20 ; 

CREATE OR REPLACE EMPV30
AS 
SELECT EMPNO, ENAME, JOB, MGR, DEPTNO
FROM EMP 
WHERE DEPTNO = 30 ; 

GRANT SELECT ON TEST.EMPV10 TO USER01 ; 
GRANT SELECT ON TEST.EMPV20 TO USER02 ; 
GRANT SELECT ON TEST.EMPV30 TO USER03 ; 

CONN USER01/ORACLE 

SELECT * FROM TEST.EMP ; -- ERROR 
SELECT * FROM TEST.EMPV10 ; 

CONN USER02/ORACLE
CREATE SYNONYM EMPV20 FOR TEST.EMPV20 ;
SELECT * FROM EMPV20 ; 
*/

-------------------------------------------------------------


CREATE OR REPLACE VIEW EMPV10
AS 
SELECT EMPNO, ENAME, JOB, MGR, DEPTNO
FROM EMP 
WHERE DEPTNO = 10 ; 

CREATE OR REPLACE VIEW EMPV20
AS 
SELECT EMPNO, ENAME, JOB, MGR, DEPTNO
FROM EMP 
WHERE DEPTNO = 20 ; 

CREATE OR REPLACE VIEW EMPV30
AS 
SELECT EMPNO, ENAME, JOB, MGR, DEPTNO
FROM EMP 
WHERE DEPTNO = 30 ; 


SELECT * 
FROM EMPV10 ; 

SELECT * 
FROM EMPV10 
WHERE EMPNO = 7839 ; 

SELECT * 
FROM EMP 
WHERE EMPNO = 7839 ; 

UPDATE EMPV10 
SET DEPTNO = 20 
WHERE EMPNO = 7839 ; 

SELECT *
FROM EMPV10 ; 

SELECT * 
FROM EMP 
WHERE EMPNO = 7839 ; 


SELECT *
FROM USER_VIEWS;

SELECT * 
FROM EMPV10 ; 

SELECT * 
FROM (SELECT EMPNO, ENAME, JOB, MGR, DEPTNO
      FROM EMP 
     WHERE DEPTNO = 10)  ;


UPDATE EMPV10 
SET DEPTNO = 20 
WHERE EMPNO = 7839 ;

UPDATE (SELECT EMPNO, ENAME, JOB, MGR, DEPTNO
        FROM EMP 
        WHERE DEPTNO = 10)
SET DEPTNO = 20 
WHERE EMPNO = 7839 ; 

--뷰는 데이터를 저장하는게아니고 원본쿼리를 저장하고있음 

SELECT * FROM EMP;

ROLLBACK ;

CREATE VIEW EMPV10 
AS
SELECT EMPNO, ENAME, JOB, MGR, SAL, DEPTNO
FROM EMP 
WHERE DEPTNO = 10 ; 

DROP VIEW EMPV10 ; 

CREATE VIEW EMPV10 
AS
SELECT EMPNO, ENAME, JOB, MGR, SAL, DEPTNO
FROM EMP 
WHERE DEPTNO = 10 ; 

CREATE OR REPLACE VIEW EMPV10 
AS
SELECT EMPNO, ENAME, JOB, MGR, SAL, DEPTNO
FROM EMP 
WHERE DEPTNO = 10 ; 

CREATE OR REPLACE VIEW EMPV10 
AS
SELECT EMPNO, ENAME, JOB, MGR, SAL, DEPTNO
FROM AMP
WHERE DEPTNO = 10 ; 

CREATE OR REPLACE FORCE VIEW EMPV10 
AS
SELECT EMPNO, ENAME, JOB, MGR, SAL, DEPTNO
FROM AMP
WHERE DEPTNO = 10 ; 

SELECT * FROM EMPV10;

CREATE OR REPLACE VIEW EMPV10 
AS
SELECT EMPNO, ENAME, JOB, MGR, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10 ; 

UPDATE EMPV10 
SET DEPTNO = 20 
WHERE EMPNO = 7839 ; 

SELECT * FROM EMPV10 ;

ROLLBACK;

CREATE OR REPLACE VIEW EMPV10 
AS
SELECT EMPNO, ENAME, JOB, MGR, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10 
WITH CHECK OPTION ;


UPDATE EMPV10    -- ERROR 
SET DEPTNO = 20 
WHERE EMPNO = 7839;


CREATE OR REPLACE VIEW EMPV_SUM
AS 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO ; 

SELECT * 
FROM EMPV_SUM ;

DELETE EMPV_SUM 
WHERE DEPTNO = 10 ; 


UPDATE EMPV_SUM
SET SUM_SAL = 20000 
WHERE DEPTNO = 10 ;


CREATE OR REPLACE VIEW EMPV10 
AS 
SELECT EMPNO, ENAME, SAL*12 ANN_SAL, DEPTNO
FROM EMP 
WHERE DEPTNO = 10 ; 

SELECT * 
FROM EMPV10 ; 

DELETE EMPV10 
WHERE EMPNO = 7839 ; 

ROLLBACK ;

UPDATE EMPV10
SET ANN_SAL = 12000
WHERE EMPNO = 7839 ; 

UPDATE EMPV10
SET DEPTNO = 20 
WHERE EMPNO = 7839 ; 

ROLLBACK ;

ALTER TABLE EMP 
MODIFY JOB NOT NULL ; 


CREATE OR REPLACE VIEW EMPV10 
AS 
SELECT EMPNO, ENAME, DEPTNO
FROM EMP 
WHERE DEPTNO = 10 ; 

SELECT * 
FROM EMPV10 ;

INSERT INTO EMPV10
VALUES (1234,'ABC',20) ;

ROLLBACK ;

--뷰는 검색은 무조건되구 DML은 뷰가 생성된 조건에따라 다르다.

/*
CREATE TABLE chatting
(TEXT VARCHAR2(4000 BYTE)) 
ORGANIZATION EXTERNAL 
(TYPE ORACLE_LOADER
 DEFAULT DIRECTORY DATA_DIR
 ACCESS PARAMETERS
 ( RECORDS DELIMITED BY NEWLINE
   BADFILE 'chatting.bad'
   LOGFILE 'chatting.log'
   FIELDS TERMINATED BY '|'
   REJECT ROWS WITH ALL NULL FIELDS)
 LOCATION
 ('chatting.txt')
)
*/

SELECT *
FROM KEYNOTE;